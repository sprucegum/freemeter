#!/usr/bin/python3
'''
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''
import psutil, serial, time, random, yaml

POLLING_HZ = 20
POLLING_PERIOD = 1.0 / POLLING_HZ

class Meter:

    def __init__(self, interval):
        print("initializing")
        with open('meter_config.yaml') as c:
            self.config = yaml.load(c.read())
        self.interval = interval
        self.currentSerial = None
        self.ser = {}
        self.serialConnect()
        self.metrics = Metrics(self)

    def serialConnect(self):
        for meter, config in self.config.items():
            print(meter, config)
            try:
                self.ser[meter] = serial.Serial(config['port'])
            except Exception as e:
                self.ser.pop(meter, None)


    def writeByte(self, i):
        self.ser[self.currentSerial].write(int(i).to_bytes(1, 'big'))

    def run(self):
        while (True):
            try:
                for meter, config in self.config.items():
                    self.currentSerial = meter
                    for pin, stat in config['pins'].items():
                        statVal = self.metrics.getMetric(stat)
                        if statVal >= 0:
                            self.writeByte(pin)
                            self.writeByte(statVal)
                    # two 255 characters signals to the meter that the command is complete.
                    self.writeByte(255)
                    self.writeByte(255)
                    time.sleep(self.interval)
            except Exception as e:
                print(e)
                self.ser[self.currentSerial].close()
                time.sleep(5)
                try:
                    self.serialConnect()
                except:
                    print("Couldn't connect")


class Metrics:

    def __init__(self, parent):
        self.parent = parent
        print("metrics module instantiated")

    # Limit values between 0 and 255
    def clamp(self, x):
        return min(255, max(0, x))

    def getCpu(self):
        loads = [(i / 100.) for i in psutil.cpu_percent(self.parent.interval, True)]
        usage = random.choice(loads)
        return self.percentTo8bit(usage)

    def avg(self, array):
        l = len(array)
        s = sum(array)
        return float(s/l)

    def getMem(self):
        vm = psutil.virtual_memory()
        return self.percentTo8bit(vm.percent / 100.0)

    # Written for a very specific time where I was tethering an wanted a visualization
    def getNet(self, interface, limit):
        recv = psutil.net_io_counters(pernic=True)[interface].bytes_recv
        sentc = psutil.net_io_counters(pernic=True)[interface].bytes_sent
        byte_sum = recv + sentc
        return self.percentTo8bit(1-(byte_sum/(limit*1024*1024)))
    

    # Accepts a value from 0 to 1, returns a char (0-255)
    def percentTo8bit(self, percent):
        return self.clamp(int(percent * 255))

    def getExec(self, stat):
        percent = eval(stat)
        return self.percentTo8bit(percent)

    def getMetric(self, stat):
        if stat == "CPU":
            return self.getCpu()
        if stat == "RAM":
            return self.getMem()
        if stat == "NET":
            return self.getNet("enp5s0u2u4u2", 1024)
        try:
            return self.getExec(stat)
        except Exception as e:
            return -1  # no stat found with this name

if __name__ == "__main__":
    meter = Meter(POLLING_PERIOD)
    meter.run()
